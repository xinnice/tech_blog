### 执行上下文

- 概念
  - 当前javascritp代码被解析和执行时所在环境的抽象概念

- 类型
  	- 全局执行上下文：全局的js代码被首次加载时创建，浏览器的全局对象是window
  	- 函数执行上下文：函数被调用时创建
  	- eval函数执行上下文：eval函数调用时创建，现在很少用（性能较低）、

### 执行上下文栈

​	  一种数据结构，存储了代码在执行期间创建的所有执行上下文，用于管理执行上下文，当全局代码加载时，会创建一个全局执行上下文并压入栈(LIFO)中，当函数调用时会创建一个函数执行上下文并压入栈中，当函数执行完成，函数执行上下文会从栈中弹出，当程序结束(关闭浏览器窗口)全局执行上下文会从栈中弹出

###   变量对象

 - 概念

   完整的执行上下文分为两个阶段，分为进入执行上下文阶段和代码执行阶段，进入执行上下文会创建变量对象，存储了当前执行上下文中变量、函数的声明，变量对象由js引擎内部实现，实际上js环境中访问不到

- 进入执行上下文（全局上下文中的变量对象指向js客户端的全局对象window ）

  创建变量对象，会把函数内部的形参、函数声明、变量声明放入变量对象中

  ```
  function fn(a,b){
  	var c=1
  	funcion d(){}
  	var e=function(){}
  }
  fn(10,20)
  //变量对象伪代码
  const OA={
  	arguments:{
      a:10,
      b:20
     },
     c:undefined, 
     d:function(){},
     e:undefined
  }
  ```

- 执行代码

  ```
  const OA={
  	arguments:{
      a:10,
      b:20
     },
     c:1, 
     d:function(){},
     e:function(){}
  }
  ```

  ### 浏览器垃圾回收机制
  
  - 引用计数（当代浏览器基本不用）
    - 在堆内存中找所有对象，如果对象有被引用则会做一个标识，没有被引用会认为该对象没用，每一轮下来，被标记的对象的内存会保留着，没被标记的对象的内存会被释放掉
    - 存在的最大的弊端，当多个对象相互引用时，多个对象会长期驻留在内存中，容易造成内存泄漏，IE老版本中会存在这个问题
  - 标记清除（常用）
    - 会在根部（全局对象）找可到达的对象，如果可以直接触及内存中的对象，会把该对象作一个标识，反之在根部中不能触及到的对象不作标识，每一轮下来把做了标识的对象内存保留，其他的对象给释放掉
  
  
  
  
  
  